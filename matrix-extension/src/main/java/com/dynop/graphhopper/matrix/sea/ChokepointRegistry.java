package com.dynop.graphhopper.matrix.sea;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.logging.Logger;
import java.util.stream.Collectors;

/**
 * Registry for maritime chokepoints loaded from metadata file.
 * 
 * <p>Chokepoints are critical narrow passages that can be excluded at query time
 * to simulate real-world scenarios (e.g., Suez Canal closure).
 * 
 * <p>The registry is loaded from {@code chokepoint_metadata.json} in the sea graph cache
 * directory, which is generated by {@link SeaLaneGraphBuilder} at build time.
 * 
 * <h2>Usage</h2>
 * <pre>{@code
 * ChokepointRegistry registry = ChokepointRegistry.loadFrom(
 *     Path.of("graph-cache/sea/chokepoint_metadata.json"));
 * 
 * // Get excluded node IDs for routing
 * Set<Integer> excluded = registry.getExcludedNodeIds(List.of("SUEZ", "PANAMA"));
 * }</pre>
 * 
 * @see Chokepoint
 * @see ChokepointAwareEdgeFilter
 */
public final class ChokepointRegistry {
    
    private static final Logger LOGGER = Logger.getLogger(ChokepointRegistry.class.getName());
    private static final ObjectMapper MAPPER = new ObjectMapper();
    
    private final Map<String, Chokepoint> chokepoints;
    private final boolean mutable;
    
    /**
     * Creates a registry from the given chokepoint map.
     * 
     * @param chokepoints Map of chokepoint ID to Chokepoint
     */
    public ChokepointRegistry(Map<String, Chokepoint> chokepoints) {
        this.chokepoints = chokepoints != null 
            ? Collections.unmodifiableMap(new HashMap<>(chokepoints))
            : Collections.emptyMap();
        this.mutable = false;
    }
    
    /**
     * Creates an empty mutable registry.
     * Use for building registries dynamically.
     */
    public ChokepointRegistry() {
        this.chokepoints = new HashMap<>();
        this.mutable = true;
    }
    
    /**
     * Add a chokepoint to the registry.
     * Only works on mutable registries (created with default constructor).
     * 
     * @param chokepoint The chokepoint to add
     * @throws UnsupportedOperationException if registry is immutable
     */
    public void addChokepoint(Chokepoint chokepoint) {
        if (!mutable) {
            throw new UnsupportedOperationException("Cannot modify immutable registry");
        }
        chokepoints.put(chokepoint.getId(), chokepoint);
    }
    
    /**
     * Load registry from a JSON metadata file.
     * 
     * @param metadataFile Path to chokepoint_metadata.json
     * @return Loaded registry
     * @throws IOException if file cannot be read or parsed
     */
    public static ChokepointRegistry loadFrom(Path metadataFile) throws IOException {
        if (!Files.exists(metadataFile)) {
            LOGGER.warning(() -> "Chokepoint metadata file not found: " + metadataFile + 
                ", using empty registry");
            return new ChokepointRegistry();
        }
        
        String json = Files.readString(metadataFile);
        ChokepointMetadata metadata = MAPPER.readValue(json, ChokepointMetadata.class);
        
        Map<String, Chokepoint> map = new HashMap<>();
        for (ChokepointEntry entry : metadata.chokepoints) {
            Chokepoint cp = new Chokepoint(
                entry.id,
                entry.name,
                entry.region,
                entry.lat,
                entry.lon,
                entry.radiusDegrees,
                entry.stepDegrees,
                new HashSet<>(entry.nodeIds)
            );
            map.put(entry.id, cp);
        }
        
        LOGGER.info(() -> String.format("Loaded %d chokepoints from %s", 
            map.size(), metadataFile.getFileName()));
        
        return new ChokepointRegistry(map);
    }
    
    /**
     * Get a chokepoint by ID.
     * 
     * @param id Chokepoint ID (e.g., "SUEZ")
     * @return Chokepoint or null if not found
     */
    public Chokepoint getChokepoint(String id) {
        return chokepoints.get(id);
    }
    
    /**
     * Get all chokepoint IDs.
     * 
     * @return Set of chokepoint IDs
     */
    public Set<String> getChokepointIds() {
        return chokepoints.keySet();
    }
    
    /**
     * Get all chokepoints.
     * 
     * @return Collection of all chokepoints
     */
    public Collection<Chokepoint> getAllChokepoints() {
        return chokepoints.values();
    }
    
    /**
     * Get all node IDs that should be excluded based on the given chokepoint list.
     * 
     * @param excludedChokepoints List of chokepoint IDs to exclude (e.g., ["SUEZ", "PANAMA"])
     * @return Set of node IDs to exclude from routing
     */
    public Set<Integer> getExcludedNodeIds(List<String> excludedChokepoints) {
        if (excludedChokepoints == null || excludedChokepoints.isEmpty()) {
            return Collections.emptySet();
        }
        
        return excludedChokepoints.stream()
            .map(this::getChokepoint)
            .filter(Objects::nonNull)
            .flatMap(cp -> cp.getNodeIds().stream())
            .collect(Collectors.toSet());
    }
    
    /**
     * Check if a chokepoint ID is valid.
     * 
     * @param id Chokepoint ID
     * @return true if the ID exists in the registry
     */
    public boolean isValidChokepoint(String id) {
        return chokepoints.containsKey(id);
    }
    
    /**
     * @return Number of chokepoints in the registry
     */
    public int size() {
        return chokepoints.size();
    }
    
    /**
     * Save registry to a JSON metadata file.
     * 
     * @param metadataFile Path to write to
     * @throws IOException if writing fails
     */
    public void saveTo(Path metadataFile) throws IOException {
        List<ChokepointEntry> entries = chokepoints.values().stream()
            .map(cp -> new ChokepointEntry(
                cp.getId(),
                cp.getName(),
                cp.getRegion(),
                cp.getLat(),
                cp.getLon(),
                cp.getRadiusDegrees(),
                cp.getStepDegrees(),
                new ArrayList<>(cp.getNodeIds())
            ))
            .collect(Collectors.toList());
        
        ChokepointMetadata metadata = new ChokepointMetadata(entries);
        
        MAPPER.writerWithDefaultPrettyPrinter()
            .writeValue(metadataFile.toFile(), metadata);
        
        LOGGER.info(() -> String.format("Saved %d chokepoints to %s", 
            entries.size(), metadataFile.getFileName()));
    }
    
    /**
     * JSON structure for chokepoint metadata file.
     */
    @JsonIgnoreProperties(ignoreUnknown = true)
    private static class ChokepointMetadata {
        @JsonProperty("chokepoints")
        List<ChokepointEntry> chokepoints;
        
        @JsonCreator
        ChokepointMetadata(@JsonProperty("chokepoints") List<ChokepointEntry> chokepoints) {
            this.chokepoints = chokepoints != null ? chokepoints : Collections.emptyList();
        }
    }
    
    /**
     * JSON structure for a single chokepoint entry.
     */
    @JsonIgnoreProperties(ignoreUnknown = true)
    private static class ChokepointEntry {
        @JsonProperty("id")
        String id;
        
        @JsonProperty("name")
        String name;
        
        @JsonProperty("region")
        String region;
        
        @JsonProperty("lat")
        double lat;
        
        @JsonProperty("lon")
        double lon;
        
        @JsonProperty("radiusDegrees")
        double radiusDegrees;
        
        @JsonProperty("stepDegrees")
        double stepDegrees;
        
        @JsonProperty("nodeIds")
        List<Integer> nodeIds;
        
        @JsonCreator
        ChokepointEntry(
                @JsonProperty("id") String id,
                @JsonProperty("name") String name,
                @JsonProperty("region") String region,
                @JsonProperty("lat") double lat,
                @JsonProperty("lon") double lon,
                @JsonProperty("radiusDegrees") double radiusDegrees,
                @JsonProperty("stepDegrees") double stepDegrees,
                @JsonProperty("nodeIds") List<Integer> nodeIds) {
            this.id = id;
            this.name = name;
            this.region = region;
            this.lat = lat;
            this.lon = lon;
            this.radiusDegrees = radiusDegrees;
            this.stepDegrees = stepDegrees;
            this.nodeIds = nodeIds != null ? nodeIds : Collections.emptyList();
        }
    }
}
